generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Event {
  id                String               @id @default(cuid())
  title             String
  eventType         String
  location          String
  latitude          Float?
  longitude         Float?
  startDate         DateTime
  endDate           DateTime?
  cost              Float?
  platformFee       Float                @default(5)
  description       String?
  isRecurring       Boolean              @default(false)
  imageUrl          String?
  minTeams          Int?
  maxTeams          Int?
  acceptedTeamTypes String[]             @default([])
  visibility        TournamentVisibility @default(PUBLIC)
  status            EventStatus          @default(UPCOMING)
  approvalStatus    EventApprovalStatus  @default(PENDING)
  rejectionReason   String?
  rejectionAppeal   String?              @db.Text
  appealStatus      AppealStatus?
  appealedAt        DateTime?
  appealResolvedAt  DateTime?
  appealResolvedBy  String?
  appealResolution  String?              @db.Text
  dismissedAt       DateTime?
  approvedAt        DateTime?
  approvedBy        String?
  bracketType       BracketType?
  bracketData       Json?
  divisions         String[]             @default([])
  maxTeamsPerClub   Int?                 @default(1)
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  clubId            String?
  pitchLocationId   String?             // Deprecated: use pitchLocations instead
  club              Club?                @relation(fields: [clubId], references: [id])
  pitchLocation     PitchLocation?       @relation("MainPitch", fields: [pitchLocationId], references: [id])
  pitchLocations    EventPitchLocation[] // New: multiple pitches support
  interests         Interest[]
  matches           Match[]
  surveyResponses   SurveyResponse[]
  teams             TournamentTeam[]
  report            EventReport?
  watchers          EventWatchlist[]
  reviewTokens      ReviewToken[]
  eventReviews      EventReview[]
  conflicts         Conflict[]
  guestTestimonials GuestTestimonial[]
  hostTestimonials  HostTestimonial[]

  @@index([startDate])
  @@index([eventType])
  @@index([location])
  @@index([clubId])
  @@index([startDate, eventType])
  @@index([latitude, longitude])
  @@index([acceptedTeamTypes])
  @@index([visibility])
  @@index([pitchLocationId])
  @@index([status])
  @@index([approvalStatus])
}

model Interest {
  id                String              @id @default(cuid())
  eventId           String
  name              String
  email             String
  message           String?
  submittedAt       DateTime            @default(now())
  applicantClubId   String?             // The club submitting the interest (for Irish clubs applying to tournaments)
  applicantClubName String?             // Name of the applying club (for display)
  status            ApplicationStatus   @default(PENDING)
  event             Event               @relation(fields: [eventId], references: [id])
  applicantClub     Club?               @relation("ClubApplications", fields: [applicantClubId], references: [id])

  @@index([eventId])
  @@index([submittedAt])
  @@index([applicantClubId])
  @@index([status])
}

model Club {
  id                  String               @id @default(cuid())
  name                String
  internationalUnitText String?            // Direct text field for form submissions
  internationalUnitId String?
  countryId           String?
  regionId            String?
  region              String?              // Legacy field - keeping for backward compatibility
  subRegion           String?              // Legacy field - keeping for backward compatibility
  map                 String?
  facebook            String?
  instagram           String?
  website             String?
  codes               String?
  imageUrl            String?
  location            String?
  latitude            Float?
  longitude           Float?
  teamTypes           String[]             @default([])
  sportsSupported     String[]             @default([])
  dataSource          String?              // e.g., "GAA_INTL", "WIKIPEDIA", "PITCH_FINDER", "USER_SUBMITTED"
  contactFirstName    String?
  contactLastName     String?
  contactEmail        String?
  contactPhone        String?
  contactCountryCode  String?
  isContactWilling    Boolean              @default(false)
  primaryContactName  String?              // For user submissions - required when user creates club
  primaryContactEmail String?              // For user submissions - required when user creates club
  notesForAdmin       String?              // Optional notes from user to admin
  status              ClubStatus           @default(PENDING)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @default(now()) @updatedAt
  submittedBy         String?
  reviewedAt          DateTime?
  reviewedBy          String?
  rejectionReason     String?
  adminNotes          String?
  verificationStatus  ClubVerificationStatus @default(UNVERIFIED)
  verifiedAt          DateTime?
  verifiedBy          String?
  verificationDetails Json?
  lastVerificationCheck DateTime?
  verificationExpiry  DateTime?
  isMainlandEurope    Boolean              @default(false) // For geo-restriction
  foundedYear         Int?
  bio                 String?              @db.Text
  twitter             String?
  tiktok              String?
  isOpenToVisitors    Boolean              @default(true)
  dayPassPrice        Float?               // Per-person day pass price for visiting teams
  dayPassCurrency     String?              @default("EUR") // Currency for day pass pricing
  bankAccountHolder   String?              // Name on bank account for payouts
  bankIban            String?              // IBAN for payouts
  bankBic             String?              // BIC/SWIFT code
  bankName            String?              // Bank name
  preferredWeekends   Json?                // Array of specific date strings for preferred hosting weekends
  twinClubId          String?              // Reference to twinned Irish club (GAA twinning initiative)
  clubType            ClubType             @default(CLUB)
  twinClub            Club?                @relation("TwinClub", fields: [twinClubId], references: [id])
  twinnedBy           Club[]               @relation("TwinClub")
  availabilitySlots   AvailabilitySlot[]
  bookings            Booking[]
  clubAdminRequests   ClubAdminRequest[]
  clubInterests       ClubInterest[]
  events              Event[]
  hostingPackages     HostingPackage[]
  pitchLocations      PitchLocation[]
  tournamentInterests TournamentInterest[]
  tournamentTeams     TournamentTeam[]
  testimonials        Testimonial[]
  calendarEvents      CalendarEvent[]
  calendarInterests   CalendarInterest[]
  blockedWeekends     BlockedWeekend[]
  calendarWatches     CalendarWatch[]
  members             User[]               @relation("ClubMembers")
  admins              User[]               @relation("ClubAdmins")
  submitter           User?                @relation("ClubSubmitter", fields: [submittedBy], references: [id])
  reviewer            User?                @relation("ClubReviewer", fields: [reviewedBy], references: [id])
  verifier            User?                @relation("ClubVerifier", fields: [verifiedBy], references: [id])
  internationalUnit   InternationalUnit?   @relation(fields: [internationalUnitId], references: [id])
  country             Country?             @relation(fields: [countryId], references: [id])
  regionRecord        Region?              @relation(fields: [regionId], references: [id])
  photos              ClubPhoto[]
  clubFriends         ClubFriend[]         @relation("ClubFriends")
  friendOf            ClubFriend[]         @relation("FriendOf")
  applications        Interest[]           @relation("ClubApplications")
  reviewTokensAsReviewer  ReviewToken[]    @relation("ReviewTokenReviewer")
  reviewTokensAsTarget    ReviewToken[]    @relation("ReviewTokenTarget")
  reviewsGiven            EventReview[]    @relation("ReviewsGiven")
  reviewsReceived         EventReview[]    @relation("ReviewsReceived")
  conflictsAsComplainant  Conflict[]       @relation("ConflictComplainant")
  conflictsAsRespondent   Conflict[]       @relation("ConflictRespondent")
  guestTestimonialsAsGuest  GuestTestimonial[] @relation("GuestTestimonialGuestClub")
  guestTestimonialsAsHost   GuestTestimonial[] @relation("GuestTestimonialHostClub")
  hostTestimonialsAsHost    HostTestimonial[]  @relation("HostTestimonialHostClub")
  hostTestimonialsAsGuest   HostTestimonial[]  @relation("HostTestimonialGuestClub")

  @@index([status])
  @@index([location])
  @@index([teamTypes])
  @@index([name])
  @@index([latitude, longitude])
  @@index([region, subRegion])
  @@index([createdAt])
  @@index([submittedBy])
  @@index([verificationStatus])
  @@index([verifiedAt])
  @@index([internationalUnitId])
  @@index([countryId])
  @@index([regionId])
  @@index([dataSource])
  @@index([clubType])
}

model User {
  id                    String               @id @default(cuid())
  email                 String               @unique
  username              String               @unique
  password              String
  name                  String?
  role                  UserRole             @default(USER)
  accountStatus         AccountStatus        @default(PENDING)
  clubId                String?
  isClubMember          Boolean              @default(false)
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  approvedAt            DateTime?
  approvedBy            String?
  rejectionReason       String?
  accounts              Account[]
  reviewedAdminRequests ClubAdminRequest[]   @relation("AdminRequestReviewer")
  clubAdminRequests     ClubAdminRequest[]
  passwordResetTokens   PasswordResetToken[]
  pitchLocations        PitchLocation[]
  pitchRequests         PitchRequest[]
  sessions              Session[]
  tournamentInterests   TournamentInterest[]
  eventReports          EventReport[]
  testimonials          Testimonial[]
  testimonialSuperAdminApprovals Testimonial[] @relation("TestimonialSuperAdminApprover")
  testimonialClubAdminApprovals  Testimonial[] @relation("TestimonialClubAdminApprover")
  guestTestimonialsWritten       GuestTestimonial[] @relation("GuestTestimonialGuestUser")
  guestTestimonialsApproved      GuestTestimonial[] @relation("GuestTestimonialApprover")
  hostTestimonialsWritten        HostTestimonial[]  @relation("HostTestimonialHostUser")
  hostTestimonialsApproved       HostTestimonial[]  @relation("HostTestimonialApprover")
  club                  Club?                @relation("ClubMembers", fields: [clubId], references: [id])
  preferences           UserPreferences?
  adminOfClubs          Club[]               @relation("ClubAdmins")
  submittedClubs        Club[]               @relation("ClubSubmitter")
  reviewedClubs         Club[]               @relation("ClubReviewer")
  verifiedClubs         Club[]               @relation("ClubVerifier")
  watchedEvents         EventWatchlist[]
  eventReviewsSuperAdminApprovals EventReview[] @relation("EventReviewSuperAdminApprover")
  eventReviewsClubAdminApprovals  EventReview[] @relation("EventReviewClubAdminApprover")
  conflictsResolved     Conflict[]           @relation("ConflictResolver")

  @@index([accountStatus])
  @@index([role])
  @@index([clubId])
  @@index([createdAt])
  @@index([email])
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?
  user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SurveyResponse {
  id                    String   @id @default(cuid())
  eventId               String?
  role                  String
  clubName              String?
  country               String
  city                  String?
  sportCode             String?
  hasTraveledAbroad     String?
  travelFrequency       String?
  destinationsVisited   String[] @default([])
  preferredMonths       String[] @default([])
  specificDestination   String?
  preferredTravelTime   String?
  teamSize              String?
  budgetPerPerson       String?
  biggestChallenge      String?
  interestedServices    String[] @default([])
  improvementSuggestion String?
  additionalFeedback    String?
  contactName           String
  contactEmail          String
  contactPhone          String?
  submittedAt           DateTime @default(now())
  ipAddress             String?
  userAgent             String?
  referrer              String?
  event                 Event?   @relation(fields: [eventId], references: [id])
}

model ClubInterest {
  id          String    @id @default(cuid())
  clubId      String
  name        String
  email       String
  clubName    String?
  message     String?
  type        String
  isRead      Boolean   @default(false)
  isArchived  Boolean   @default(false)
  respondedAt DateTime?
  submittedAt DateTime  @default(now())
  club        Club      @relation(fields: [clubId], references: [id])

  @@index([clubId])
  @@index([clubId, isArchived])
}

model ClubAdminRequest {
  id              String                 @id @default(cuid())
  userId          String
  clubId          String
  reason          String
  status          ClubAdminRequestStatus @default(PENDING)
  requestedAt     DateTime               @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?
  rejectionReason String?
  club            Club                   @relation(fields: [clubId], references: [id])
  reviewer        User?                  @relation("AdminRequestReviewer", fields: [reviewedBy], references: [id])
  user            User                   @relation(fields: [userId], references: [id])

  @@unique([userId, clubId])
  @@index([status])
  @@index([clubId])
  @@index([requestedAt])
}

model HostingPackage {
  id              String    @id @default(cuid())
  clubId          String
  name            String
  description     String?
  basePrice       Float
  dayPassPrice    Float?
  maxTeams        Int       @default(1)
  maxParticipants Int?
  services        String[]  @default([])
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  bookings        Booking[]
  club            Club      @relation(fields: [clubId], references: [id])
}

model Booking {
  id            String          @id @default(cuid())
  clubId        String
  packageId     String?
  contactName   String
  contactEmail  String
  contactPhone  String?
  teamName      String
  teamSize      Int
  arrivalDate   DateTime
  departureDate DateTime
  totalAmount   Float
  platformFee   Float
  clubEarnings  Float
  status        BookingStatus   @default(INQUIRY)
  notes         String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  club          Club            @relation(fields: [clubId], references: [id])
  package       HostingPackage? @relation(fields: [packageId], references: [id])
  payments      Payment[]
}

model Payment {
  id              String        @id @default(cuid())
  bookingId       String
  amount          Float         // Total amount collected
  type            PaymentType
  status          PaymentStatus @default(PENDING)
  stripePaymentId String?
  processedAt     DateTime?
  releasedAt      DateTime?     // When funds were released to host
  withheldAt      DateTime?     // When funds were withheld
  withheldReason  String?       // Reason for withholding
  createdAt       DateTime      @default(now())

  // Financial breakdown
  hostEarnings      Float?      // Amount going to host club
  platformFee       Float?      // Amount going to GGE platform
  platformFeeShare  Float?      // Host's share of platform fee (€2.50 for day passes)

  // For day passes, track quantities
  quantity          Int?        // Number of teams or players
  unitPrice         Float?      // Price per unit (set by club for day passes)

  booking         Booking       @relation(fields: [bookingId], references: [id])

  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([bookingId])
}

model TournamentTeam {
  id           String     @id @default(cuid())
  eventId      String
  clubId       String
  teamName     String
  teamType     String
  division     String?
  registeredAt DateTime   @default(now())
  status       TeamStatus @default(REGISTERED)
  awayMatches  Match[]    @relation("AwayTeam")
  homeMatches  Match[]    @relation("HomeTeam")
  winnerReports    EventReport[] @relation("WinnerTeam")
  runnerUpReports  EventReport[] @relation("RunnerUpTeam")
  thirdPlaceReports EventReport[] @relation("ThirdPlaceTeam")
  club         Club       @relation(fields: [clubId], references: [id])
  event        Event      @relation(fields: [eventId], references: [id])

  @@unique([eventId, clubId, teamName, division])
  @@index([division])
}

model Match {
  id         String         @id @default(cuid())
  eventId    String
  homeTeamId String?
  awayTeamId String?
  division   String?
  matchDate  DateTime?
  venue      String?
  round      String?
  bracketPosition Int?
  nextMatchId String?
  homeScore  Int?
  awayScore  Int?
  status     MatchStatus    @default(SCHEDULED)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  awayTeam   TournamentTeam? @relation("AwayTeam", fields: [awayTeamId], references: [id])
  event      Event          @relation(fields: [eventId], references: [id])
  homeTeam   TournamentTeam? @relation("HomeTeam", fields: [homeTeamId], references: [id])
  nextMatch  Match?         @relation("NextMatch", fields: [nextMatchId], references: [id])
  previousMatches Match[]    @relation("NextMatch")
  
  @@index([bracketPosition])
  @@index([nextMatchId])
  @@index([division])
}

model AvailabilitySlot {
  id          String   @id @default(cuid())
  clubId      String
  date        DateTime
  isRecurring Boolean  @default(false)
  dayOfWeek   Int?
  timeSlots   String[]
  capacity    Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  club        Club     @relation(fields: [clubId], references: [id])

  @@index([clubId, date])
  @@index([date])
}

model TournamentInterest {
  id             String           @id @default(cuid())
  userId         String
  clubId         String
  interestType   InterestType
  specificDate   DateTime?
  monthYear      DateTime?
  dateRangeStart DateTime?
  dateRangeEnd   DateTime?
  teamSize       Int
  teamType       String?          // e.g., "hurling", "camogie", "lgfa", "minor", "dads_lads", "g4mo", etc.
  flexibility    FlexibilityLevel @default(FLEXIBLE)
  message        String?
  status         InterestStatus   @default(PENDING)
  suggestedDates DateTime[]
  clubResponse   String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  club           Club             @relation(fields: [clubId], references: [id])
  user           User             @relation(fields: [userId], references: [id])

  @@index([clubId, status])
  @@index([userId])
  @@index([monthYear])
  @@index([status])
  @@index([teamType])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  used      Boolean  @default(false)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
}

model UserPreferences {
  id                  String   @id @default(cuid())
  userId              String   @unique
  motivations         String[]
  competitiveLevels   String[]
  preferredCities     String[]
  preferredCountries  String[]
  preferredClubs      String[]
  activities          String[]
  budgetRange         String?
  maxFlightTime       Int?
  preferredMonths     String[]
  onboardingCompleted Boolean  @default(false)
  onboardingSkipped   Boolean  @default(false)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

enum UserRole {
  SUPER_ADMIN
  CLUB_ADMIN
  GUEST_ADMIN
  USER
}

enum AccountStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

enum ClubStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TournamentVisibility {
  PUBLIC
  PRIVATE
}

enum ClubAdminRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BookingStatus {
  INQUIRY
  QUOTE_SENT
  CONFIRMED
  DEPOSIT_PAID
  FULL_PAID
  COMPLETED
  CANCELLED
}

enum PaymentType {
  DEPOSIT
  FULL_PAYMENT
  REFUND
  TEAM_TICKET       // Per team fee (price set by host, platform takes fixed fee)
  DAY_PASS          // Per player fee (price set by host + platform fee split 50/50)
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  RELEASED    // Funds released to host after successful trip
  WITHHELD    // Funds withheld due to dispute
}

enum TeamStatus {
  REGISTERED
  CONFIRMED
  WITHDRAWN
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  POSTPONED
}

enum InterestType {
  SPECIFIC_DATE
  ENTIRE_MONTH
  DATE_RANGE
  MULTIPLE_MONTHS
}

enum FlexibilityLevel {
  FIXED
  FLEXIBLE
  VERY_FLEXIBLE
}

enum InterestStatus {
  PENDING
  IN_DISCUSSION
  APPROVED
  REJECTED
  CANCELLED
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  WAITLISTED
  REJECTED
  WITHDRAWN
}

enum ClubVerificationStatus {
  UNVERIFIED
  PENDING_VERIFICATION
  VERIFIED
  EXPIRED
  DISPUTED
}

enum PitchRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ReportStatus {
  DRAFT
  PUBLISHED
}

enum EventStatus {
  UPCOMING
  ACTIVE
  CLOSED
}

enum EventApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AppealStatus {
  PENDING
  APPROVED
  DENIED
}

enum BracketType {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  GROUP_STAGE
}

model CityDefaultImage {
  id        String   @id @default(cuid())
  city      String   @unique
  imageUrl  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([city])
}

model PitchLocation {
  id        String   @id @default(cuid())
  name      String
  address   String?
  city      String
  latitude  Float
  longitude Float
  clubId    String
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Basic pitch information
  originalPurpose String?  // Original sport the pitch was built for
  surfaceType     String?  // Grass, artificial turf, sand-based, hybrid, etc.
  numberOfPitches Int?     // How many pitches at this location
  
  // Amenities
  hasFloodlights    Boolean @default(false)
  floodlightHours   String? // Operating hours if available
  changingRooms     String? // Description of changing facilities
  spectatorFacilities String? // Stand capacity, terracing info
  parking           String? // Parking availability details
  otherAmenities    String? // Clubhouse, catering, equipment storage
  
  // Availability & Booking
  seasonalAvailability String? // Winter restrictions, close seasons
  bookingSystem       String?  // How to book, contact process
  bookingLeadTime     String?  // Advance booking requirements
  
  // Capacity & Restrictions
  maxPlayerCapacity   Int?    // Maximum players
  maxSpectatorCapacity Int?   // Maximum spectators
  ageGroupSuitability String? // Youth, Adult, Mixed
  tournamentCapacity  Int?    // Teams for tournaments
  equipmentProvided   String? // Goals, line marking, etc.
  
  // Contact & Navigation
  contactName        String? // Pitch contact person
  contactPhone       String? // Contact phone number
  contactEmail       String? // Contact email
  customDirections   String? // Special navigation instructions
  
  // History
  previousEvents     String? // Description of past events held here
  
  club      Club     @relation(fields: [clubId], references: [id])
  creator   User     @relation(fields: [createdBy], references: [id])
  events    Event[]  @relation("MainPitch")
  eventPitchLocations EventPitchLocation[]
  
  @@index([city])
  @@index([clubId])
  @@index([latitude, longitude])
}

model PitchRequest {
  id          String              @id @default(cuid())
  userId      String
  clubId      String
  pitchName   String
  address     String?
  city        String
  message     String?
  status      PitchRequestStatus  @default(PENDING)
  createdAt   DateTime            @default(now())
  processedAt DateTime?
  processedBy String?
  
  user        User                @relation(fields: [userId], references: [id])
  
  @@index([clubId])
  @@index([status])
  @@index([userId])
}

model EventReport {
  id              String         @id @default(cuid())
  eventId         String         @unique
  createdBy       String
  status          ReportStatus   @default(DRAFT)
  
  // Tournament Results (optional)
  winnerTeamId    String?
  runnerUpTeamId  String?
  thirdPlaceTeamId String?
  
  // Participating Teams
  participatingTeams Json?       // Array of {teamId, teamName, clubName, finalPosition}
  
  // Match Results Summary
  matchResults    Json?          // Array of key match results with scores
  
  // Bracket Data Snapshot
  finalBracket    Json?          // Final bracket state for visualization
  
  // Player Awards (optional)
  playerAwards    Json?          // Array of {awardType, playerName, teamName}
  
  // Event Details
  amenitiesProvided String?      // Free text describing what was included (meals, drinks, etc.)
  eventHighlights   String?      // Key moments or highlights from the event
  summary          String?       // Overall event summary
  
  // Media (to be implemented later)
  mediaUrls       String[]       @default([])
  
  // Metadata
  publishedAt     DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  // Relations
  event           Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  creator         User           @relation(fields: [createdBy], references: [id])
  winnerTeam      TournamentTeam? @relation("WinnerTeam", fields: [winnerTeamId], references: [id])
  runnerUpTeam    TournamentTeam? @relation("RunnerUpTeam", fields: [runnerUpTeamId], references: [id])
  thirdPlaceTeam  TournamentTeam? @relation("ThirdPlaceTeam", fields: [thirdPlaceTeamId], references: [id])
  
  @@index([eventId])
  @@index([status])
  @@index([createdBy])
}

// Join table for many-to-many relationship between Events and PitchLocations
model EventPitchLocation {
  id              String        @id @default(cuid())
  eventId         String
  pitchLocationId String
  isPrimary       Boolean       @default(false) // Mark primary venue
  notes           String?       // Specific notes for this venue in this event
  createdAt       DateTime      @default(now())
  
  event           Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  pitchLocation   PitchLocation @relation(fields: [pitchLocationId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, pitchLocationId])
  @@index([eventId])
  @@index([pitchLocationId])
}

model Testimonial {
  id                    String              @id @default(cuid())
  clubId                String
  userId                String
  content               String              @db.VarChar(500)
  status                TestimonialStatus   @default(PENDING)
  displayOrder          Int                 @default(0)
  deleteRequested       Boolean             @default(false)
  deleteRequestedAt     DateTime?
  submittedAt           DateTime            @default(now())
  superAdminApprovedAt  DateTime?
  superAdminApprovedBy  String?
  clubAdminApprovedAt   DateTime?
  clubAdminApprovedBy   String?
  updatedAt             DateTime            @updatedAt
  
  club                  Club                @relation(fields: [clubId], references: [id], onDelete: Cascade)
  user                  User                @relation(fields: [userId], references: [id])
  superAdminApprover    User?               @relation("TestimonialSuperAdminApprover", fields: [superAdminApprovedBy], references: [id])
  clubAdminApprover     User?               @relation("TestimonialClubAdminApprover", fields: [clubAdminApprovedBy], references: [id])
  
  @@unique([clubId, userId])
  @@index([clubId, status])
  @@index([userId])
  @@index([status])
  @@index([displayOrder])
}

enum TestimonialStatus {
  PENDING
  SUPER_ADMIN_APPROVED
  APPROVED
  REJECTED
}

// Guest Testimonials - Travelling clubs reviewing their host experience
model GuestTestimonial {
  id                    String              @id @default(cuid())
  // The travelling club writing the review
  guestClubId           String
  guestUserId           String
  // The host club being reviewed
  hostClubId            String
  // Optional: linked to a specific event/trip
  eventId               String?
  content               String              @db.VarChar(500)
  rating                Int?                // 1-5 star rating (optional)
  status                TestimonialStatus   @default(PENDING)
  displayOrder          Int                 @default(0)
  deleteRequested       Boolean             @default(false)
  deleteRequestedAt     DateTime?
  deleteRequestedBy     String?             // Which club requested deletion
  submittedAt           DateTime            @default(now())
  approvedAt            DateTime?
  approvedBy            String?
  updatedAt             DateTime            @updatedAt

  guestClub             Club                @relation("GuestTestimonialGuestClub", fields: [guestClubId], references: [id], onDelete: Cascade)
  guestUser             User                @relation("GuestTestimonialGuestUser", fields: [guestUserId], references: [id])
  hostClub              Club                @relation("GuestTestimonialHostClub", fields: [hostClubId], references: [id], onDelete: Cascade)
  event                 Event?              @relation(fields: [eventId], references: [id])
  approver              User?               @relation("GuestTestimonialApprover", fields: [approvedBy], references: [id])

  @@unique([guestClubId, hostClubId, eventId])
  @@index([guestClubId])
  @@index([hostClubId, status])
  @@index([status])
  @@index([displayOrder])
}

// Host Testimonials - Host clubs reviewing the travelling teams they hosted
model HostTestimonial {
  id                    String              @id @default(cuid())
  // The host club writing the review
  hostClubId            String
  hostUserId            String
  // The travelling club being reviewed
  guestClubId           String
  // Optional: linked to a specific event/trip
  eventId               String?
  content               String              @db.VarChar(500)
  rating                Int?                // 1-5 star rating (optional)
  status                TestimonialStatus   @default(PENDING)
  displayOrder          Int                 @default(0)
  deleteRequested       Boolean             @default(false)
  deleteRequestedAt     DateTime?
  deleteRequestedBy     String?             // Which club requested deletion
  submittedAt           DateTime            @default(now())
  approvedAt            DateTime?
  approvedBy            String?
  updatedAt             DateTime            @updatedAt

  hostClub              Club                @relation("HostTestimonialHostClub", fields: [hostClubId], references: [id], onDelete: Cascade)
  hostUser              User                @relation("HostTestimonialHostUser", fields: [hostUserId], references: [id])
  guestClub             Club                @relation("HostTestimonialGuestClub", fields: [guestClubId], references: [id], onDelete: Cascade)
  event                 Event?              @relation(fields: [eventId], references: [id])
  approver              User?               @relation("HostTestimonialApprover", fields: [approvedBy], references: [id])

  @@unique([hostClubId, guestClubId, eventId])
  @@index([hostClubId])
  @@index([guestClubId, status])
  @@index([status])
  @@index([displayOrder])
}

// New models for cascading club selection
model InternationalUnit {
  id          String      @id @default(cuid())
  code        String      @unique
  name        String
  displayOrder Int        @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  countries   Country[]
  clubs       Club[]
  
  @@index([displayOrder])
}

model Country {
  id                  String              @id @default(cuid())
  code                String              @unique
  name                String
  internationalUnitId String
  hasRegions          Boolean             @default(false)
  displayOrder        Int                 @default(0)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  internationalUnit   InternationalUnit   @relation(fields: [internationalUnitId], references: [id])
  regions             Region[]
  clubs               Club[]
  
  @@index([internationalUnitId])
  @@index([displayOrder])
}

model Region {
  id          String      @id @default(cuid())
  code        String
  name        String
  countryId   String
  displayOrder Int        @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  country     Country     @relation(fields: [countryId], references: [id])
  clubs       Club[]
  
  @@unique([countryId, code])
  @@index([countryId])
  @@index([displayOrder])
}

model ClubSubmission {
  id                  String      @id @default(cuid())
  name                String
  internationalUnitId String?
  countryId           String?
  regionId            String?
  countryName         String?     // For manual entries
  regionName          String?     // For manual entries
  sportsSupported     String[]    @default([])
  website             String?
  email               String?
  status              SubmissionStatus @default(PENDING)
  submittedBy         String
  submittedAt         DateTime    @default(now())
  reviewedBy          String?
  reviewedAt          DateTime?
  approvalNotes       String?
  rejectionReason     String?
  convertedToClubId   String?     // Reference to created club if approved
  
  @@index([status])
  @@index([submittedBy])
  @@index([submittedAt])
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  DUPLICATE
}

// Calendar-specific models for the new Club Admin Calendar feature
model CalendarEvent {
  id              String            @id @default(cuid())
  clubId          String
  title           String
  description     String?
  eventType       CalendarEventType
  eventSource     EventSource
  fixtureType     FixtureType?
  crestType       CrestType         @default(CLUB)
  startDate       DateTime
  endDate         DateTime?
  startTime       String?
  endTime         String?
  location        String?
  notes           String?
  isBlocked       Boolean           @default(false)
  conflictWarning String?
  createdBy       String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  club            Club              @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId, startDate])
  @@index([startDate])
  @@index([eventType])
  @@index([eventSource])
}

model CalendarInterest {
  id                String    @id @default(cuid())
  clubId            String
  userId            String
  date              DateTime
  preferredLocation String?
  submissionCount   Int       @default(1)
  isAnonymous       Boolean   @default(false) // True when viewed by club admins
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  club              Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([clubId, userId, date])
  @@index([clubId, date])
  @@index([date])
  @@index([userId])
}

model BlockedWeekend {
  id          String    @id @default(cuid())
  clubId      String
  startDate   DateTime
  endDate     DateTime
  reason      String?
  blockedBy   String
  createdAt   DateTime  @default(now())

  club        Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId, startDate])
  @@index([startDate, endDate])
}

model Holiday {
  id          String        @id @default(cuid())
  country     String
  date        DateTime
  name        String
  type        HolidayType
  cachedAt    DateTime      @default(now())

  @@unique([country, date, type])
  @@index([country, date])
  @@index([date])
}

model PriorityWeekend {
  id          String    @id @default(cuid())
  date        DateTime
  message     String
  createdBy   String
  createdAt   DateTime  @default(now())

  @@unique([date])
  @@index([date])
}

model CalendarWatch {
  id                  String    @id @default(cuid())
  clubId              String
  date                DateTime
  userId              String
  addedToMailingList  Boolean   @default(false)
  createdAt           DateTime  @default(now())

  club                Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@unique([clubId, date, userId])
  @@index([clubId, date])
  @@index([date])
}

model ArchivedInterest {
  id                String    @id @default(cuid())
  clubId            String
  userId            String
  date              DateTime
  preferredLocation String?
  submissionCount   Int
  originalCreatedAt DateTime
  archivedAt        DateTime  @default(now())

  @@index([clubId])
  @@index([archivedAt])
}

model CalendarDigestLog {
  id          String    @id @default(cuid())
  sentAt      DateTime  @default(now())
  recipients  String[]
  success     Boolean
  errorMessage String?
  metrics     Json?     // Store KPIs and stats for the digest

  @@index([sentAt])
}

enum CalendarEventType {
  FIXTURE
  TRAINING
  TOURNAMENT
  SOCIAL
}

enum EventSource {
  CLUB
  FIXTURE
  SYSTEM
}

enum FixtureType {
  COMPETITIVE
  INVITATIONAL
}

enum CrestType {
  CLUB
  EUROPE_GAA
}

enum HolidayType {
  PUBLIC
  SCHOOL
}

model ClubPhoto {
  id           String   @id @default(cuid())
  clubId       String
  url          String
  caption      String?
  order        Int      @default(0)
  isCoverPhoto Boolean  @default(false)
  createdAt    DateTime @default(now())

  club      Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@index([clubId])
}

model ClubFriend {
  id            String   @id @default(cuid())
  clubId        String
  friendClubId  String
  visitYear     Int?
  notes         String?
  createdAt     DateTime @default(now())

  club          Club     @relation("ClubFriends", fields: [clubId], references: [id], onDelete: Cascade)
  friendClub    Club     @relation("FriendOf", fields: [friendClubId], references: [id], onDelete: Cascade)

  @@unique([clubId, friendClubId])
  @@index([clubId])
  @@index([friendClubId])
}

model EventWatchlist {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

// Email automation system
model EmailTemplate {
  id          String            @id @default(cuid())
  type        EmailTemplateType @unique
  name        String
  subject     String
  body        String            @db.Text
  isActive    Boolean           @default(true)
  variables   String[]          @default([]) // Available template variables like {{userName}}, {{tripDate}}
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  logs        EmailLog[]

  @@index([type])
  @@index([isActive])
}

model EmailLog {
  id          String          @id @default(cuid())
  templateId  String?
  templateType EmailTemplateType?
  recipientEmail String
  recipientName  String?
  subject     String
  status      EmailStatus     @default(PENDING)
  sentAt      DateTime?
  errorMessage String?
  metadata    Json?           // Store context like bookingId, eventId, etc.
  createdAt   DateTime        @default(now())

  template    EmailTemplate?  @relation(fields: [templateId], references: [id])

  @@index([templateId])
  @@index([templateType])
  @@index([recipientEmail])
  @@index([status])
  @@index([createdAt])
  @@index([sentAt])
}

enum EmailTemplateType {
  WELCOME                    // New user registration
  BOOKING_CONFIRMATION       // Booking confirmed
  BOOKING_REMINDER           // Reminder before trip
  PRE_DEPARTURE              // Pre-departure info pack
  POST_TRIP_FEEDBACK         // Request for review/feedback after trip
  ADMIN_NEW_BOOKING          // Admin notification of new booking
  ADMIN_NEW_USER             // Admin notification of new user
  CLUB_ADMIN_NEW_INTEREST    // Club admin notification of new interest
  PASSWORD_RESET             // Password reset email
  TOURNAMENT_REGISTRATION    // Tournament registration confirmation
}

enum EmailStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}

enum ClubType {
  CLUB
  UNIVERSITY
  SCHOOL
  COUNTY
}

// Neutral venues for hosting future events (admin-only)
model NeutralVenue {
  id              String   @id @default(cuid())
  name            String
  city            String
  country         String
  address         String?
  latitude        Float?
  longitude       Float?

  // Pitch details
  numberOfPitches Int?
  surfaceType     String?  // Grass, artificial, hybrid
  pitchSize       String?  // Full size, 3/4, etc.
  hasFloodlights  Boolean  @default(false)

  // Facilities
  changingRooms   String?
  parking         String?
  spectatorCapacity Int?
  cateringOnSite  Boolean  @default(false)
  accommodationNearby String?

  // Contact information
  contactName     String?
  contactEmail    String?
  contactPhone    String?
  contactRole     String?  // e.g., "Facilities Manager", "Groundskeeper"

  // Booking & availability
  typicalCost     String?  // e.g., "€500/day", "Negotiable"
  bookingNotes    String?  @db.Text
  bestTimeToContact String?

  // Admin notes
  notes           String?  @db.Text
  lastContacted   DateTime?
  relationshipStatus String? // e.g., "Cold", "In talks", "Good relationship", "Used before"

  // Metadata
  addedBy         String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([country])
  @@index([city])
  @@index([createdAt])
}

// Post-Event Review System Models

model ReviewToken {
  id              String       @id @default(cuid())
  token           String       @unique
  eventId         String
  reviewerClubId  String
  targetClubId    String
  expiresAt       DateTime
  used            Boolean      @default(false)
  createdAt       DateTime     @default(now())

  event           Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  reviewerClub    Club         @relation("ReviewTokenReviewer", fields: [reviewerClubId], references: [id])
  targetClub      Club         @relation("ReviewTokenTarget", fields: [targetClubId], references: [id])
  review          EventReview?

  @@index([token])
  @@index([eventId])
  @@index([expiresAt])
}

model EventReview {
  id                    String            @id @default(cuid())
  tokenId               String            @unique
  eventId               String
  reviewerClubId        String
  targetClubId          String

  rating                Int
  content               String?           @db.VarChar(500)
  complaint             String?           @db.Text
  improvementSuggestion String?           @db.Text

  status                EventReviewStatus @default(PENDING)
  isConflict            Boolean           @default(false)

  superAdminApprovedAt  DateTime?
  superAdminApprovedBy  String?
  clubAdminApprovedAt   DateTime?
  clubAdminApprovedBy   String?

  submittedAt           DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  token                 ReviewToken       @relation(fields: [tokenId], references: [id])
  event                 Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  reviewerClub          Club              @relation("ReviewsGiven", fields: [reviewerClubId], references: [id])
  targetClub            Club              @relation("ReviewsReceived", fields: [targetClubId], references: [id])
  superAdminApprover    User?             @relation("EventReviewSuperAdminApprover", fields: [superAdminApprovedBy], references: [id])
  clubAdminApprover     User?             @relation("EventReviewClubAdminApprover", fields: [clubAdminApprovedBy], references: [id])
  conflict              Conflict?

  @@unique([eventId, reviewerClubId, targetClubId])
  @@index([targetClubId, status])
  @@index([isConflict])
  @@index([status])
}

enum EventReviewStatus {
  PENDING
  SUPER_ADMIN_APPROVED
  APPROVED
  REJECTED
  CONFLICT_OPEN
  CONFLICT_RESOLVED
}

model Conflict {
  id                String           @id @default(cuid())
  reviewId          String           @unique
  eventId           String
  complainantClubId String
  respondentClubId  String

  status            ConflictStatus   @default(OPEN)
  priority          ConflictPriority @default(MEDIUM)

  adminNotes        String?          @db.Text
  resolutionNotes   String?          @db.Text
  resolutionType    ResolutionType?
  resolvedAt        DateTime?
  resolvedBy        String?

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  review            EventReview      @relation(fields: [reviewId], references: [id])
  event             Event            @relation(fields: [eventId], references: [id])
  complainantClub   Club             @relation("ConflictComplainant", fields: [complainantClubId], references: [id])
  respondentClub    Club             @relation("ConflictRespondent", fields: [respondentClubId], references: [id])
  resolver          User?            @relation("ConflictResolver", fields: [resolvedBy], references: [id])

  @@index([status])
  @@index([respondentClubId])
  @@index([eventId])
}

enum ConflictStatus {
  OPEN
  IN_PROGRESS
  AWAITING_RESPONSE
  RESOLVED
  DISMISSED
}

enum ConflictPriority {
  LOW
  MEDIUM
  HIGH
}

enum ResolutionType {
  MEDIATED
  REFUND_ISSUED
  APOLOGY_ISSUED
  NO_ACTION
  WARNING_ISSUED
  DISMISSED
}

// GAA Fixtures - Key dates when Irish clubs won't travel
model GAAFixture {
  id          String            @id @default(cuid())
  date        DateTime          // The fixture date
  endDate     DateTime?         // For multi-day events (e.g., weekend)
  title       String            // e.g., "All-Ireland Hurling Final"
  description String?           // Additional context
  impact      GAAFixtureImpact  @default(HIGH)
  year        Int               // Year for easy filtering
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([date])
  @@index([year])
}

enum GAAFixtureImpact {
  MEDIUM
  HIGH
  CRITICAL
}

model ContactSubmission {
  id          String                  @id @default(cuid())
  name        String
  email       String
  subject     String
  message     String                  @db.Text
  status      ContactSubmissionStatus @default(NEW)
  respondedAt DateTime?
  respondedBy String?
  response    String?                 @db.Text
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt

  @@index([status])
  @@index([createdAt])
  @@index([email])
}

enum ContactSubmissionStatus {
  NEW
  READ
  RESPONDED
  ARCHIVED
}
